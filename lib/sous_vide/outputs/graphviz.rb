module SousVide
  module Outputs
    # Saves the report to a DOT file that can be used with Graphviz's "dot" utility
    # to generate a graph.
    #
    # Default file name is "sous-vide-report.dot".
    #
    # Default directory is Chef file cache path
    #
    # @example
    #   digraph {
    #   compund=true; // allows connecting subgraphs
    #   node [shape=plaintext]
    #   
    #   node_1
    #   subgraph cluster_node_1 {
    #    node_2
    #    subgraph cluster_node_2 {
    #     node_3
    #     subgraph cluster_node_3 {
    #      node_4
    #     } // node_3
    #    } // node_2
    #   } // node_1
    #   node_5
    #   
    #   RUN_START -> node_1
    #   node_1 -> node_5
    #   node_4 -> node_5 [style=invis]
    #   node_1 -> node_2 [dir=back, style=dashed, lhead=cluster_node_1]
    #   node_2 -> node_3 [dir=back, style=dashed, lhead=cluster_node_2]
    #   node_3 -> node_4 [dir=back, style=dashed, lhead=cluster_node_3]
    #   node_5 -> RUN_END
    #   }
    class Graphviz
      def initialize(logger: nil, file_name: nil, directory: nil)
        @directory = directory || Chef::Config[:file_cache_path]
        @file_name = file_name || "sous-vide-report.dot"
        @destination = ::File.join(@directory, @file_name)
        @logger = logger
      end

      # Saves the dot-graph to a file.
      def call(run_data:, node_data:, resources_data:)
        graph = Graph.new

        resources_data.sort_by(&:execution_order).each do |event|
          graph.add_node_from_chef_event(event)
        end

        ::File.write(@destination, graph.render)
      end

      # This class encapsulates all logic related to graph building. It provides methods to add
      # nodes & render the final graph.
      #
      # It maintains nodes as part of it's state, but otherwise it's stateless. Edges are also
      # part of the state, but they are discarded and rebuilt on each call to :render method.
      class Graph
        attr_reader :nodes, :edges

        def initialize
          @nodes = []
          @edges = []

          @run_start_node = Node.new
          @run_start_node.depth = 0
          @run_start_node.id = "RUN_START"

          @run_end_node = Node.new
          @run_end_node.depth = 0
          @run_end_node.id = "RUN_END"

          @execution_phase = nil
        end

        # Helper method to build a node directly from a SousVide event and add it to the graph.
        #
        # @param chef_resource [Chef::Resource]
        #
        # @return [void]
        #
        # @see SousVide::Outputs::Graphviz::Graph#add_node
        # @see SousVide::Outputs::Graphviz::Node.from_chef_resource
        def add_node_from_chef_event(chef_resource)
          node = Node.from_chef_resource(chef_resource.to_h)
          add_node(node)
        end

        # Adds a node to the graph. Nodes have to be added to the graph in correct order or it
        # may crash if one node descends multiple levels at once (this never occurs in input
        # generated by SousVide).
        #
        # @param node [SousVide::Outputs::Graphviz::Node]
        #
        # @return [void]
        #
        # @see SousVide::Outputs::Graphviz::Node#add_child
        def add_node(node)
          if node.phase != @execution_phase
            inject_execution_phase_node!(node.phase)
          end

          # Only top level nodes will be added directly, evertyhing else is passed to the
          # add_child method of the last node which will traverse all children recursively until
          # it finds correct parent.
          if node.depth.zero?
            @nodes << node
          else
            @nodes.last.add_child(node)
          end
        end

        # Renders a full graph in dot format.
        #
        # @return [String]
        def render
          build_edges!

          <<~EOS
            digraph {
            compund=true; // allows connecting subgraphs
            node [shape=plaintext]

            #{nodes.join("\n")}

            #{edges.join("\n")}
            }
          EOS
        end

        # Builds edges between all nodes added to the graph. Discards any previously built edges.
        # Called in #render, it should not be ever needed to be called otherwise.
        #
        # Used in Cucumber tests too.
        #
        # @api private
        def build_edges!
          all_nodes = [@run_start_node] + @nodes + [@run_end_node]

          # The very last node will not have 'children_edges' included, but that's okay because
          # it has none (it's the run_end_node).
          @edges = all_nodes.each_cons(2).flat_map do |n1, n2|
            n1.connect_to(n2) + n1.children_edges
          end
        end

        private

        # Injects a simple text node when chef-client execution phase has changed.
        #
        # @param phase [String] chef-client execution phase
        #
        # @return [void]
        #
        # @api private
        def inject_execution_phase_node!(phase)
          phase_change_node = Node.new
          phase_change_node.depth = 0
          phase_change_node.id = "PHASE_#{phase.to_s.upcase}"
          phase_change_node.label = "Execution phase changed to '#{phase.to_s}'"
          @execution_phase = phase
          @nodes << phase_change_node
        end
      end

      # This class represents a graph node, usually created from a SousVide event, but in some
      # cases nodes are created manually. It maintains children nodes and can render itself (a
      # node), it's children (a cluster) and all the edges.
      class Node
        attr_accessor :id, :depth, :name, :type, :action, :order,
                      :label, :status, :duration, :phase

        # Builds a Node from an event generated by SousVide.
        #
        # @return [SousVide::Outputs::Graphviz::Node]
        def self.from_chef_resource(chef_resource)
          node = Node.new
          node.depth    = chef_resource[:chef_resource_nest_level]
          node.name     = chef_resource[:chef_resource_name]
          node.type     = chef_resource[:chef_resource_type]
          node.action   = chef_resource[:chef_resource_action]
          node.order    = chef_resource[:chef_resource_order]
          node.status   = chef_resource[:chef_resource_status]
          node.duration = chef_resource[:chef_resource_duration_ms]
          node.phase    = chef_resource[:chef_resource_execution_phase]

          node
        end

        def initialize
          @children = []
        end

        # Returns a node ID, defaults to 'node_<order>'.
        #
        # @return [String]
        def id
          @id ||= "node_#{@order}"
        end

        # Adds a child node. If it's "deeper" than immediate children then it will be added to
        # the last child instead (and still as a child).
        #
        # Note: this works because nodes are ordered and descend 1 level at a time at most. This
        # method is called directly on a top level nodes only and it will traverse down the path
        # until it finds appropriate parent (one level above) at which point it's added as a child
        # directly.
        #
        # @param node [SousVide::Outputs::Graphviz::Node] a node to be added as a child (any depth)
        # @return [void]
        def add_child(node)
          if node.depth == (self.depth + 1)
            @children << node
          else
            @children.last.add_child(node)
          end
        end

        # Connects the node with another. This is a direct connection and both nodes should be at
        # the same depth.
        #
        # @return [Array<String>] an array of edges (strings), one or more
        def connect_to(other)
          edges = [ "#{id} -> #{other.id}" ]

          # Connect last (inner-most) child node with invisible edge so the graph is well aligned.
          # It ensures each node is drawn on a separate "level" and the graph is "flat". Without
          # it clusters would end up at the same row as the following node.
          if @children.any?
            edges << "#{self.last_child.id} -> #{other.id} [style=invis]"
          end

          edges
        end

        # Connects all children recursively.
        #
        # @return [Array<String>] an array of all children edges
        def children_edges
          return [] if @children.empty?

          # Connect self to the cluster of children with inverted arrow.
          cluster_edge = [ "#{id} -> #{@children.first.id} [dir=back, style=dashed, lhead=cluster_#{id}]" ]

          children_direct_edges = @children.each_cons(2).flat_map do |n1, n2|
            n1.connect_to(n2)
          end

          # Expand all children recursively
          children_nested_edges = @children.flat_map(&:children_edges)

          cluster_edge +
            children_direct_edges +
            children_nested_edges
        end

        # Returns last and inner-most child so it can be used to draw invisible edge.
        # If a node has no children it will return self.
        #
        # @return [SousVide::Outputs::Graphviz::Node] a very last child or self
        def last_child
          if @children.any?
            @children.last.last_child
          else
            self
          end
        end

        # Returns a dot representation of the node, including children. If the node has children
        # this method will return a subgraph cluster.
        #
        # @return [String]
        def to_s
          padding = " " * @depth

          node = "#{padding}#{id} [label=#{label}]"

          if @children.any?
            # 'blues9' color scheme defines 9 shades of blue, indexed 1 to 9. As the nesting depth
            # increases so will the color and it will wrap around if needed.
            cluster_color = (@depth % 9) + 1

            <<~EOS.chomp
              #{node}
              #{padding}subgraph cluster_#{id} {
              #{padding} style = filled;
              #{padding} colorscheme = blues9;
              #{padding} fillcolor = #{cluster_color};
              #{@children.map(&:to_s).join("\n")}
              #{padding}} // #{id}
            EOS
          else
            node
          end
        end

        # Returns a dot-friendly label, either a custom string wrapped in double-quotes or, if not
        # set, html-like label (wrapped in '<' & '>').
        #
        # @return [String] the node label to be used in dot-file
        def label
          if @label
            %Q<"#{@label}">
          else
            "<#{html_table_label}>"
          end
        end

        private

        # Returns a html-like node label
        #
        # @return [String] the node label to be used in dot-file
        def html_table_label
          <<~EOS.chomp
            <TABLE BORDER="0" CELLBORDER="1" CELLSPACING="0" BGCOLOR="#{label_color}">
              <TR><TD COLSPAN="2">#{@order}. #{@type}[#{@name}]</TD></TR>
              <TR><TD>action</TD><TD>#{@action}</TD></TR>
              <TR><TD>status</TD><TD>#{@status}</TD></TR>
              <TR><TD>duration</TD><TD>#{@duration} ms</TD></TR>
            </TABLE>
          EOS
        end

        # Returns a color used in html-like labels. Used to color-code execution status.
        #
        # @return [String]
        def label_color
          case @status
          when "up-to-date"  then "#66CC99"
          when "updated"     then "#FFDC00"
          when "skipped"     then "#DDDDDD"
          when "why-run"     then "#6699FF"
          when "failed"      then "#FF4136"
          when "unprocessed" then "white"
          else "white"
          end
        end
      end
    end
  end
end
