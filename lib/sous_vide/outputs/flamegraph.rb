module SousVide
  module Outputs
    # Saves the report to a flamegraph file ('sous-vide-report.flame' by default).
    #
    # This file can be passed directly to 'flamegraph.pl' tool.
    #
    # Default unit flamegraph uses is samples, but SousVide will provide millis instead.  Similarly
    # the resources are ordered (and padded) as this allows correct alphabetical sorting.
    #
    # Pallete can be generated to color-code resources based on status. This is not automatic and
    # is provided when using `bin/flamegraph` script.
    #
    # @example flamegraph.pl usage
    #   flamegraph.pl sous-vide-report.flame --countname ms --cp --width 5000 > graph.svg
    #
    # @example sous-vide-report.flame
    #  converge;29.mysql_service[foo]#start(updated) 61
    #  converge;29.mysql_service[foo]#start(updated);30.mysql_service_manager_upstart[foo]#start(updated) 4
    #  converge;29.mysql_service[foo]#start(updated);30.mysql_service_manager_upstart[foo]#start(updated);31.template[/usr/sbin/mysql-foo-wait-ready]#create(updated) 13
    #  converge;29.mysql_service[foo]#start(updated);30.mysql_service_manager_upstart[foo]#start(updated);32.template[/etc/init/mysql-foo.conf]#create(updated) 9
    #  converge;29.mysql_service[foo]#start(updated);30.mysql_service_manager_upstart[foo]#start(updated);33.service[mysql-foo]#start(updated) 36
    #
    # Note the final SVG generated from flamegraph.pl is not necessary pretty because Chef
    # resources are generally shallow (depth 0, sometimes 1), but some community cookbooks provide
    # multi-level resources that can get tricky to understand otherwise and flamegraph can help.
    #
    # See https://github.com/brendangregg/FlameGraph to learn more about flamegraphs.
    class Flamegraph
      def initialize(logger: nil, file_name: nil, directory: nil)
        @directory = directory || Chef::Config[:file_cache_path]
        @file_name = file_name || "sous-vide-report.flame"
        @destination = ::File.join(@directory, @file_name)
        @logger = logger
      end

      # Saves the flamegraph to a file.
      def call(run_data:, node_data:, resources_data:)
        graph = Graph.new

        resources_data.sort_by(&:execution_order).each do |event|
          graph.add_node_from_chef_event(event)
        end

        ::File.write(@destination, graph.render)
      end

      # This class contains logic related to graph building and rendering.
      #
      # It can render the graph and the palette separately.
      class Graph
        def initialize
          @nodes = []
        end

        # Helper method to build a node directly from a SousVide event and add it to the graph.
        #
        # @param chef_resource [Chef::Resource]
        #
        # @return [void]
        #
        # @see SousVide::Outputs::Graphviz::Graph#add_node
        # @see SousVide::Outputs::Graphviz::Node.from_chef_resource
        def add_node_from_chef_event(chef_resource)
          node = Node.from_chef_resource(chef_resource.to_h)
          add_node(node)
        end

        # Adds a node to the graph. Nodes have to be added to the graph in correct order or it
        # may crash if one node descends multiple levels at once (this never occurs in input
        # generated by SousVide).
        #
        # @param node [SousVide::Outputs::Flamegraph::Node]
        #
        # @return [void]
        #
        # @see SousVide::Outputs::Flamegraph::Node#add_child
        def add_node(node)
          if node.depth.zero?
            @nodes << node
          else
            @nodes.last.add_child(node)
          end
        end

        # Returns a flame graph. Pass it to flamegraph.pl script to generate SVG.
        #
        # Samples are milliseconds and if a node has zero millis duration it would not be rendered
        # in SVG. For this reason force 1 millisecond duration minimum. It introduces some
        # inaccuracy, but it's insignificant and having all resources present in the graph is more
        # important.
        #
        # @return [String] the flamegraph to pass to flamegraph.pl tool
        def render
          expanded_nodes = @nodes.flat_map(&:to_a)
          order_width = expanded_nodes.size.to_s.size

          expanded_nodes.map do |node|
            # Nodes with children have their duration calculated and it could be zero or negative
            # in some cases.
            positive_duration = (node.duration < 1) ? 1 : node.duration

            "#{node.phase};#{node.render(order_rjust: order_width)} #{positive_duration}"
          end.join("\n")
        end

        # Outputs 'palette.map' for flamegraph tool. It will include color codes for every
        # resource based on status. The colors match Graphviz output. It's intended for use with
        # '--cp' flag.
        #
        # @return [String] content for 'palette.map' file
        def palette
          expanded_nodes = @nodes.flat_map(&:to_a)
          order_width = expanded_nodes.size.to_s.size

          nodes_colors = expanded_nodes.map do |node|
            "#{node.render(order_rjust: order_width, with_parents: false)}->#{node.color}"
          end

          phase_colors = [
            "compile->#B0DFE5",
            "converge->#95C8D8",
            "delayed->#588BAE",
            "post-converge->#81D8D0"
          ]

          (phase_colors + nodes_colors).join("\n")
        end
      end

      # This class represents a graph node created from a SousVide generated event. It maintains
      # parent-child relation and it can render itself with or without parents, but it does not
      # render individual children. To render node and it's children call `#to_a` and iterate
      # over the array.
      class Node
        attr_accessor :depth, :duration, :phase, :action, :name, :type, :order, :parent, :status

        def initialize
          @children = []
        end

        # Builds a Node from an event generated by SousVide. Input can be a parsed JSON generated
        # by SousVide. Keys must be symbolized.
        #
        # @return [SousVide::Outputs::Graphviz::Node]
        def self.from_chef_resource(chef_resource)
          node = Node.new
          node.depth    = chef_resource[:chef_resource_nest_level]
          node.name     = chef_resource[:chef_resource_name]
          node.type     = chef_resource[:chef_resource_type]
          node.action   = chef_resource[:chef_resource_action]
          node.order    = chef_resource[:chef_resource_order]
          node.duration = chef_resource[:chef_resource_duration_ms]
          node.phase    = chef_resource[:chef_resource_execution_phase]
          node.status   = chef_resource[:chef_resource_status]

          node
        end

        # Renders the node, optionally excluding parents. This method, unlike Graphviz, will not
        # render all children. To do so call `#to_a` and iterate over all elements.
        #
        # @example with parent
        #   09.mysql_service[foo]#create(updated);10.mysql_server_installation_package[foo]#install(updated)
        #
        # The order is zero-padded so all entries can be sorted alphabetically.
        # Spaces and semicolons are control characters and are not allowed.
        #
        # @return [String] a node in flamegraph format
        def render(order_rjust: 0, with_parents: true)
          padded_order = @order.to_s.rjust(order_rjust, "0")
          name = "#{padded_order}.#{@type}[#{@name}]##{@action}(#{@status})".gsub(/\s|;/, '_')

          if with_parents && @parent
            parent_name = @parent.render(order_rjust: order_rjust)
            name = "#{parent_name};#{name}"
          end

          name
        end

        # Expands children and returns a flat array containing self and children.
        #
        # @return [Array<SousVide::Outputs::Flamegraph::Node>]
        def to_a
          [ self ] + @children.flat_map(&:to_a)
        end

        # Adds a child node, either as a direct children or to the last (more recent) child.  This
        # expects input to be ordered correctly.
        #
        # @return [void]
        def add_child(node)
          if node.depth == (self.depth + 1)
            node.parent = self
            @children << node
          else
            @children.last.add_child(node)
          end
        end

        # Returns duration excluding children duration so the flamegraph shows time spent in this
        # node correctly.
        #
        # @return [Fixnum] duration in ms, substracting children (can be zero or negative)
        def duration
          if @children.any?
            @duration - @children.map(&:duration).reduce(:+)
          else
            @duration
          end
        end

        # Returns node color, based on it's execution status. The colors match Graphviz output.
        #
        # @return [String]
        def color
          case @status
          when "up-to-date"  then "#66CC99"
          when "updated"     then "#FFDC00"
          when "skipped"     then "#DDDDDD"
          when "why-run"     then "#6699FF"
          when "failed"      then "#FF4136"
          when "unprocessed" then "white"
          else "white"
          end
        end
      end
    end
  end
end
